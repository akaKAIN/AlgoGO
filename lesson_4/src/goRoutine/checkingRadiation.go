package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
)

type AutoGenerated []struct {
	InfmeassystID       int    `json:"infmeassyst_id"`
	RmFullname          string `json:"rm_fullname"`
	RmInfmeassystTypeID int    `json:"rm_infmeassyst_type_id"`
	RmName              string `json:"rm_name"`
	RmParentID          int    `json:"rm_parent_id,omitempty"`
	StateID             int    `json:"state_id"`
	Stations            []struct {
		GeoLon          float64 `json:"geo_lon"`
		GeoLat          float64 `json:"geo_lat"`
		RmID            int     `json:"rm_id"`
		RmInfmeassystID int     `json:"rm_infmeassyst_id"`
		RmName          string  `json:"rm_name"`
		RmShortName     string  `json:"rm_short_name"`
		Mobile          bool    `json:"mobile"`
		StateID         int     `json:"state_id"`
		Channels        []struct {
			RmBorderAccident      float64 `json:"rm_border_accident"`
			RmBorderWarning       float64 `json:"rm_border_warning"`
			RmID                  int     `json:"rm_id"`
			RmMaxValidValue       float64 `json:"rm_max_valid_value"`
			RmMeasurableValueName string  `json:"rm_measurable_value_name"`
			RmMinValidValue       float64 `json:"rm_min_valid_value"`
			RmName                string  `json:"rm_name"`
			RmSyncPeriodAccident  int     `json:"rm_sync_period_accident"`
			RmSyncPeriodNormal    int     `json:"rm_sync_period_normal"`
			RmUnitmeasureName     string  `json:"rm_unitmeasure_name"`
			StationID             int     `json:"station_id"`
			LastValue             struct {
				Date    int64   `json:"date"`
				StateID int     `json:"state_id"`
				Value   float64 `json:"value"`
			} `json:"last_value"`
		} `json:"channels"`
		GeoAlt int `json:"geo_alt,omitempty"`
	} `json:"stations"`
}

const (
	URL = "http://91.238.188.112:8080/appserver/rest/system/all"
	maxBorder = 6.0 * 10e3
)

func (a AutoGenerated) AllExceeded(){
	var count int
	fmt.Println("\n+=========================================================================+")
	for i := range a {
		for _, station := range a[i].Stations{
			for _, channel := range station.Channels {
				if channel.LastValue.Value > maxBorder {
					count++
					fmt.Printf("%s: %.fмЗв\n", channel.RmName, channel.LastValue.Value/1000)
				}
			}
		}
	}
	fmt.Println("+=========================================================================:", count)
}

func signalHandler(ch <-chan os.Signal) {
	//Обработка сигналов прерывания через Ctrl+C
	s := <-ch
	fmt.Printf("Get %s signal. Stopped.", s)
	os.Exit(1)
}

func init() {
	//Обработка согналов прерывания через Ctrl+C
	var ch = make(chan os.Signal)
	var stopSignal = syscall.SIGINT
	signal.Notify(ch, stopSignal)
	go signalHandler(ch)
}

func main() {

	var a = AutoGenerated{}
	resp, err := http.Get(URL)
	if err != nil {
		log.Fatal(err)
	}
	defer func() {
		if err := resp.Body.Close(); err != nil {
			log.Fatal(err)
		}
	}()
	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	if err = json.Unmarshal(data, &a); err != nil {
		log.Fatal(err)
	}

	byteData, err := json.Marshal(a)
	if err != nil {
		log.Fatal(err)
	}

	err = ioutil.WriteFile("answer.json", byteData, os.ModePerm)
	if err != nil {
		log.Fatal("Cannot write file:", err)
	}

	a.AllExceeded()

}
